% Пример деления списка на 2 подсписка

domains
namelist=name*
name=integer

predicates

split(name,namelist,namelist,namelist)

clauses
split(Middle,[Head|Tail],[Head|L1],L2):-  %  точка 1
Head<=Middle,
split(Middle,Tail,L1,L2).


split(Middle,[Head|Tail],L1,[Head|L2]):-  % точка 2
split(Middle,Tail,L1,L2),
Head>Middle.
split(_,[],[],[]).   % точка3


goal

split(40,[30,50,20,25,65,95],L1,L2),
write(L1),nl,
write(L2).

/*
1 проход Переменные L1,L2 пока не означены Пролог в цели использует анонимные переменные
Middle=40, Head=30 проверка 30<=40 Успех и производится рекурсивный вызов в точке 1
Списку L1 присоединяется 30
Head=50 и первая подцель первого правила дает неуспех. Откат в точку 2
Здесь переменной L2 присоединяется элемент 50 без проверки условия
Head>Middle.В этой точке запоминается точка возврата после работы со стеком. И снова рекрсивный вызов в точку 1 и т.д. до тех пор пока
первый список в цели не станет пустым. Тогда откат в точку 3.
Цель примет вид split(40,[],[],[]), т.е. анонимные переменные примут вид пустого списка
и из стека начинают извлекаться элементы; причем первым извлекается последний обработанный элемент,
т.е. 95, затем 65, 50 и каждый раз производится проверка условия во втором правиле
Head>Middle. Но элементы 20 и 25 не проверяются т.к. они были обработыны ранее.
Когда  стек становится пустым, цель удовлетворена и производится вывод списков.
*/