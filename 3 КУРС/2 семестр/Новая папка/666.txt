using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace kr
{
    class Program
    {
        class Polynomial
        {
            public List<int> Arguments;
            public Polynomial(int[] arr)
            {
                Arguments = new List<int>();
                for (int i = 0; i < arr.Length; i++)
                    Arguments.Add(arr[i]);
            }
            public Polynomial(int n)
            {
                Arguments = new List<int>();
                for (int i = 0; i < n; i++)
                    Arguments.Add(0);
            }
            public Polynomial(Polynomial polynomial)
            {
                Arguments = new List<int>();
                for (int i = 0; i < polynomial.GetDegree(); i++)
                    Arguments.Add(polynomial.Arguments[i]);
            }
            public Polynomial(List<int> arr)
            {
                Arguments = new List<int>();
                for (int i = 0; i < arr.Count; i++)
                    Arguments.Add(arr[i]);
            }
            public Polynomial()
            {
                Arguments = new List<int>();
            }
            public int Value(int x)
            {
                int value = 0;
                for (int i = 0; i < Arguments.Count; i++)
                    value += (int)Math.Pow(x, i) * Arguments[i];
                return value;
            }
            public int this[int index]
            {
                get
                {
                    try
                    {
                        return Arguments[index];
                    }
                    catch
                    {
                        return 0;
                    }
                }
                set
                {
                    if (!(index < 0))
                        Arguments[index] = value;
                }
            }
            public int GetDegree()
            {
                return Arguments.Count;
            }
            public static Polynomial operator -(Polynomial a)
            {
                Polynomial c = new Polynomial(a.GetDegree());
                for (int i = 0; i < a.GetDegree(); i++)
                    c[i] = a[i] * -1;
                return c;
            }
            public static Polynomial operator +(Polynomial a, Polynomial b)
            {
                int max = Math.Max(a.GetDegree(), b.GetDegree());
                Polynomial c = new Polynomial(max);
                for (int i = 0; i < max; i++)
                    c[i] = a[i] + b[i];
                return c;
            }
            public static Polynomial operator -(Polynomial a, Polynomial b)
            {
                return a + -b;
            }
            public static Polynomial operator *(Polynomial a, Polynomial b)
            {
                int max = Math.Max(a.GetDegree(), b.GetDegree());
                Polynomial c = new Polynomial(a.GetDegree() * b.GetDegree());
                for (int i = 0; i < a.GetDegree(); i++)
                    for (int j = 0; j < b.GetDegree(); j++)
                        c[i + j] += a[i] * b[j];
                return c;
            }
            void Reduction()
            {
                int k = GetDegree() - 1;
                while (this[k] == 0 && GetDegree() > 0)
                {
                    Arguments.RemoveAt(k);
                    k--;
                }
            }
            public static Polynomial[] operator /(Polynomial a, Polynomial b)
            {
                a.Reduction();
                b.Reduction();
                if (a.GetDegree() < b.GetDegree())
                    throw new ArgumentException("Некорректная степень многочленов");
                Polynomial c = new Polynomial((a.GetDegree() - b.GetDegree()) + 1);
                Polynomial d = new Polynomial(a.Arguments);
                Polynomial temp;
                int i = 0;
                while (d.GetDegree() >= b.GetDegree() && d[d.GetDegree() - 1] >= b[b.GetDegree() - 1])
                {
                    Polynomial d1 = new Polynomial(d);
                    c[c.GetDegree() - i - 1] = d[a.GetDegree() - i - 1] / b[b.GetDegree() - 1];
                    //Console.WriteLine(a + " " + b);
                    Polynomial temp1 = new Polynomial(c.GetDegree());


                    //d.GetDegree() >= b.GetDegree();
                    //                                                                                                                                                                                                                                                if (i > 10) break;
                    temp1[c.GetDegree() - i - 1] = c[c.GetDegree() - i - 1];
                    temp = b * temp1;
                    d = d - temp;
                    i++;

                    int k = d.GetDegree() - 1;
                    while (d[k] == 0 && d.GetDegree() > 0)
                    {
                        d.Arguments.RemoveAt(k);
                        k--;
                    }

                    if (c.ToString() == "0")
                    {
                        Polynomial[] res1 = { new Polynomial(), new Polynomial() };
                        return res1;
                    }
                }
                if (d.GetDegree() < 0)
                    d = new Polynomial();

                Polynomial[] res = { c, d };
                return res;
            }
            public static Polynomial operator /(Polynomial a, int b)
            {
                Polynomial c = new Polynomial(a.GetDegree());
                for (int i = 0; i < a.GetDegree(); i++)
                    c[i] = a[i] / b;
                return c;
            }
            public static Polynomial operator *(Polynomial a, int b)
            {
                Polynomial c = new Polynomial(a.GetDegree());
                for (int i = 0; i < a.GetDegree(); i++)
                    c[i] = a[i] * b;
                return c;
            }
            public static bool operator ==(Polynomial a, Polynomial b)
            {
                if (a.GetDegree() == b.GetDegree())
                {
                    for (int i = 0; i < a.GetDegree(); i++)
                        if (a[i] != b[i])
                            return false;
                    return true;
                }
                else
                    return false;
            }
            public static bool operator !=(Polynomial a, Polynomial b)
            {
                return !(a == b);
            }
            public override string ToString()
            {
                string s = "";
                for (int i = GetDegree() - 1; i >= 0; i--)
                    if (Arguments[i] != 0)
                        s += Arguments[i].ToString() + "x^" + i.ToString() + '+';

                if (s == "")
                    s = "0";
                else
                    s = s.Remove(s.Length - 1, 1);
                return s;
            }
            public static Polynomial Interpolate(int[] ax, int[] ay)
            {
                Polynomial res = new Polynomial();
                for (int i = 0; i < ax.Length; i++)
                {
                    /*
                    Кол-во выполнений равно кол-ву точек
                    В формуле многочлена лагранжа колличетсво слагаемых равно кол-ву точек
                    Этот цикл будет выполнен ровно столько же раз
                     */

                    Polynomial num = new Polynomial();
                    int divider = 1; //Изначально 1, потому что при делении числа на 1 получается то же самое число
                    for (int j = 0; j < ax.Length; j++)
                    {
                        /*
                         Этот цикл выполняет формирование очередного слагаемого
                         */
                        if (i != j)
                        {
                            int[] a = { -ax[j], 1 }; // Часть дроби - числитель: x - xi
                            num = (num == new Polynomial()) ? //Если пустой, то создаем мерый множитель, если нет - домножаем
                                new Polynomial(a) : num *= new Polynomial(a); //Запись числителя
                            divider *= (ax[i] - ax[j]); //Вычисление знаменателя
                        }
                    }
                    /*
                     num хранит числитель
                     divider хранит знаменатель
                     */
                    if (res == new Polynomial()) //Если это первая иттерация цикла, то задаётся пустой многочлен
                    {
                        res = num * ay[i] / divider; //Формула слагаемого
                        Console.WriteLine("Теперь res = " + res);
                    }
                    else
                    {
                        res += num * ay[i] / divider; //Формула слагаемого
                        Console.WriteLine("Теперь res = " + res);
                    }
                }
                res.Reduction(); //Удаление справа стоящих нулей
                return res;
            }
        }
        static bool exitflag = false;
        static List<Polynomial> fact_kron(Polynomial polynomial)
        {
            Polynomial polynomialTmp = new Polynomial(polynomial);//Хранит в себе исходны многочлен для случая исключения
            List<Polynomial> res = new List<Polynomial>();//Массив многочленов, ответ
            Polynomial workPol = new Polynomial(polynomial);//Исходный многочлен, изменяющийся для нахождения всех делителей

            while (true)
            {
                Polynomial temp = kronecker(workPol);
                if (exitflag) //exitflag - отвечает за случай, при котором одно из значений многочлена в точке 0...1..n/2 делится на 0
                {
                    res = new List<Polynomial>();//на всякий случай очистка результирующего листа
                    res.Add(temp);//добавление многочлена формата a = { -i, 1 } как исключения
                    if (((polynomialTmp / temp)[0]).Arguments[0] != 0)
                        res.Add((polynomialTmp / temp)[0]);//добавления результата деления исходного многочлена на a = { -i, 1 }
                    return res;
                }

                if (temp == new Polynomial() || workPol == new Polynomial())//возврат результата при наличии нулевого многочлена в одной из переменных
                {
                    res.Add(workPol);//добавление последнего многочлена, не должно работать когда выходи из цикла по второй части условия после ||
                    return res;
                }
                else
                {
                    res.Add(temp);
                    workPol = (workPol / temp)[0];//Деление исходного многочлена на результат выполднения метода кронейкера для него
                    //далее выполнение цикла с многочленом меньшей степени
                    /*
                     * если перемножить многочлен кронейкера для исходного многочлена (для конкрето этого шага)
                     * c многочленом, который получится в резултате деления исходного многочлена на многочлен полученный методом кронейкера,
                     * то получится исходный многочлен.
                     * по этому это процедура называется fact - факторизация многочелна - представления многочелна в виде 
                     * произведения двух других меньшей степени
                     */
                }
            }
        }

        static Polynomial kronecker(Polynomial polynomial)
        {
            int n = polynomial.GetDegree() - 1;

            for (int i = 0; i <= n / 2; i++)
            {
                if (polynomial.Value(i) == 0) //Нахождение значения многочлена в точках 0..1..2..n/2
                {
                    int[] a = { -i, 1 };//если значения многочлена в точке равно 0, то ответ это многочлен вида x-i, и многочлена полученный
                    //делением исходного на многочлен x-i
                    //Console.WriteLine("exit!!!");
                    exitflag = true;
                    return new Polynomial(a);
                }
            }

            List<int> U1 = factors(polynomial.Value(0));//Делители значения многочлена в точке 0
            List<List<int>> U = new List<List<int>>(); //Инициализация за пределами цикла для того, чтобы было с чем перемножать
            foreach (int i in U1)
            {
                List<int> x = new List<int>();
                x.Add(i);
                U.Add(x);
            }
            for (int i = 1; i <= n / 2; i++)
            {
                List<int> M = factors(polynomial.Value(i));//Делители значения многочлена в точке i
                U = decart(U, M);
                Console.WriteLine("Список комбинаций для составления многочлена лагранжа: ");
                Console.WriteLine("---");
                foreach (List<int> j in U)
                {
                    foreach (var item in j)
                    {
                        Console.Write(item + " ");
                    }
                    Console.WriteLine("");
                }
                Console.WriteLine("---");
                foreach (List<int> j in U)
                {
                    
                    List<int> ax = new List<int>();
                    List<int> ay = new List<int>();
                    for (int k = 0; k < i + 1; k++)
                    {
                        //Составление таблицы для интерполяции
                        ax.Add(k); //Добавление индекса - значения X в таблицу 0 1 2 ... n
                        ay.Add(j[k]); //Добавление инекса - значения Y в таблицу (значения в точке)
                    }

                    Console.Write("Таблица для интерполяции:\nx\t");
                    foreach (var item in ax)
                    {
                        Console.Write(item + " \t");
                    }
                    Console.Write("\ny:\t");
                    foreach (var item in ay)
                    {
                        Console.Write(item + " \t");
                    }
                    Console.WriteLine();
                    Polynomial x = //Хранит многочлен Лагранжа
                    Polynomial.Interpolate(ax.ToArray(), ay.ToArray()); //Отправка таблицы значений x(y) для интерполяции - составления Лагранжа
                    Console.WriteLine("Получившийся многочлен Лагранжа: " + x);
                    if (x != new Polynomial() && x.GetDegree() > 1) //Если получился не пустой многочлен и его степень больше 1
                    {
                        Polynomial[] y = polynomial / x; // Деление, для полученя остатка
                        if (
                            y[1] == new Polynomial() && // y[1] - это остаток от операции деления 
                            y[0] != new Polynomial()) //y[0] - результат деления
                            return x; //Возвращаяет не пустой многочлен, который будет добавлен в ответ
                    }
                }
            }
            return new Polynomial(); //Возвращает пустой многочлен, который не будет добавлен в ответ
        }

        static List<int> factors(int x)
        {
            x = Math.Abs(x);
            List<int> fact = new List<int>();
            for (int i = 1; i <= Math.Sqrt(Math.Abs(x)); i++)//цикл до значения корня числа, потому что на большие он априори не может делиться
            {
                if (x % i == 0)
                {
                    //Добавление значений с разными знаками
                    fact.Add(i);
                    fact.Add(-i);
                }
            }
            fact.Add(x);//Число делится само на себя
            fact.Add(-x);
            return fact;
        }

        static List<List<int>> decart(List<List<int>> a, List<int> b)
        {
            List<List<int>> res = new List<List<int>>();
            foreach (List<int> ax in a)
                foreach (int bx in b)
                {
                    List<int> x = new List<int>();
                    for (int i = 0; i < ax.Count; i++)
                        x.Add(ax[i]);
                    x.Add(bx);
                    res.Add(x);
                }
            return res;
        }

        static void Main(string[] args)
        {
            //int[] a = { -1, 6, -8, -2, -1, 1 };
            //int[] a = { 1, 2, 1 };
            //int[] a = { -1, 0, 0, 1 };
            int[] a = { -1, 6, -8, -2, -1, 1 };
            //int[] a = { -1, 6, -8, -2, -1, 1 };
            //int[] a = { 3, 6, 6, 6, 3 };
            Polynomial polynomial = new Polynomial(a);
            Console.WriteLine("Многочлен:");
            //x^4-2
            Console.WriteLine(polynomial);
            //Console.ReadKey();
            List<Polynomial> ap = fact_kron(polynomial);
            Console.WriteLine("Многочлен:");
            //x^4-2
            Console.WriteLine(polynomial);
            Console.WriteLine("Множители:");

            for (int i = 0; i < ap.Count; i++)
                Console.WriteLine(ap[i]);

            //int[] x = { 0, 1, 2 };
            //         int[] y = { 1, -5, 3 };
            //         Polynomial lagr = Polynomial.Interpolate(x,y);
            //         Console.WriteLine("lagr ="+lagr);

            Console.ReadKey();
        }
    }
}

