// zadanie_1124.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
/*Стратегия:
*Представлять поле и цвета в виде графика, где каждый блок является узлом, а каждый цвет не в
* его правильная коробка - это край, указывающий на правильную коробку.Мы должны найти кратчайший путь
* (Путь Эйлера) через граф.
* Поскольку вход является перестановкой, эта перестановка может быть выражена как последовательность
* транспозиции ввода.Каждое перемещение двух узлов в графе сохраняет свои градусы
* в 0. Поскольку все узлы имеют четные градусы, у нас есть путь Эйлера через каждый(связанный)
* компонент графика.Это означает, что нам нужно только сделать дополнительные переходы к каждому компоненту
* график, кроме того, в котором мы начинаем, поэтому конечным результатом является количество компонентов графика
* выше 1, плюс количество ребер.
*
* Представление:
*O(MN).Это оптимально, поскольку вход имеет такой размер.Тестовые случаи выполняются за 0, 046 с и
* использовать 1380 КБ памяти.*/

#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <algorithm>

int main()
{
	int M, N, e = 0; // Количество ребер
	scanf_s("%d %d", &M, &N);
	std::vector<bool> vis(M + 1, false); // Метки посещенных узлов при выполнении dfs
	std::vector<std::vector<int>> adj(M + 1); // матрица смежности

	for (int i = 1; i <= M; i++)
	{
		adj[i].reserve(M);
		for (int j = 1; j <= N; j++)
		{
			int x;
			scanf_s("%d", &x);
			if (x != i)
			{   // Добавьте ребро для каждого цвета не в своей коробке
				e++;
				adj[i].push_back(x);
			}
		}
	}

	int c = 0; // Количество связанных компонентов в графике
	std::vector<int> stack(M * N);
	int top = 0;
	for (int i = 1; i <= M; i++)
	{   // Простой dfs; подсчитайте количество подключенных компонентов
		if (!vis[i] && !adj[i].empty())
		{
			c++;
			stack[top++] = i;
			while (top != 0)
			{
				int k = stack[--top];
				vis[k] = true;
				for (auto it = adj[k].begin(); it < adj[k].end(); it++)
				{
					if (!vis[*it])
						stack[top++] = *it;
				}
			}
		}
	}

	int ans = e + std::max(0, c - 1);
	printf("%d\n", ans);
	return 0;
}
