// zadanie_1988.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

/*Стратегия:
 * Переведите задачу на двумерную поверхность, используя угол между векторами местоположения
 * космический корабль и носитель (с центром планеты, являющимся источником) и размещение космического корабля
* по оси х. Затем выясните касательную точку планеты относительно космического корабля.
 * Это позволяет нам легко рассчитать общее время в пути, если космический корабль и перевозчик
* вверх в некоторой точке на поверхности, определяемой углом между точкой и осью х. троичный
 * Поиск может быть использован для расчета оптимального времени.
 *
 * Представление:
 * Константа, запускает тесты за 0,001 с использованием памяти 336 КБ.*/


#include <iostream>
#include <iomanip>
#include <cmath>
#include <iostream>
#include <algorithm>

struct point
{
	double x, y;
	point(double x = 0, double y = 0) : x(x), y(y) {}
	point operator- (const point& p) { return point(x - p.x, y - p.y); }
	point operator/ (const double t) { return point(x / t, y / t); }
	double dist() { return std::sqrt(x * x + y * y); }
};

int main()
{
	double x1, y1, z1, x2, y2, z2, v;
	std::cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2 >> v;
	double r = std::sqrt(x1 * x1 + y1 * y1 + z1 * z1); // Расстояние до перевозчика
	double d = std::sqrt(x2 * x2 + y2 * y2 + z2 * z2); // Расстояние до космического корабля
	double t = std::acos((x1 * x2 + y1 * y2 + z1 * z2) / (r * d)); // Угол между ними

	const double pi = std::acos(-1.0);
	double D = std::sqrt(d * d - r * r); // Расстояние до точки касания
	double s = pi / 2 - atan(r / D); // Угол между осью x (на которой находится корабль) и выше

	// Вычисляет наибольшее время, затрачиваемое на транспортировку перевозчика и космического корабля
	// в точку на планете с углом u с осью x
	auto calc = [&t, &s, &r, &v, &d, &D](double u)
	{
		point p(std::cos(u) * r, std::sin(u) * r), B(d, 0); // Место встречи и местоположение корабля
		return u < s ? std::max((t - u) * r, (p - B).dist() / v) // Место встречи, видимое космическим кораблем
			: std::max(D / v + (u - s) * r / v, (t - u) * r); // Место встречи за касательной
	};

	double L = 0, R = t, x, y;
	for (int i = 0; i < 50; i++) // троичный поиск
	{
		x = calc(L + (R - L) / 3);
		y = calc(L + 2 * (R - L) / 3);
		if (x < y)
			R = L + 2 * (R - L) / 3;
		else
			L = L + (R - L) / 3;
	}
	std::cout << std::setprecision(20) << x;
}
