<<<<<<< HEAD
#include <iostream>
#include <math.h>
#include <mpi.h>
#include <string>
#include <algorithm>

using namespace std;

const int answerTag = 0;
const int feedbackTag = 1;

//  1 - по возрастанию, -1 - по убыванию, 0 - массив равен, INT_MAX - разные
int checkArray(int* arr, int size)
{
	int result = 0;
	for (int i = 1; i < size; ++i)
	{
		int temp = 0;
		if (arr[i - 1] < arr[i])
			temp = 1;
		else if (arr[i - 1] > arr[i])
			temp = -1;

		if (result == 0)
			result = temp;
		else if (result != temp && temp != 0)
		{
			result = INT_MAX;
			break;
		}
	}
	return result;
}

int main(int argc, char* argv[])
{
	int proc_rank, proc_num;
	MPI_Status st;
	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &proc_rank);
	MPI_Comm_size(MPI_COMM_WORLD, &proc_num);
	double start, end;
	int n;
	int* arr = NULL;
	if (proc_rank == 0)
	{
		std::cout << "Input N:";
		n = pow(10, 8);
		cout << n << endl;
		//std::cin >> n;
		std::cout << "Choose:\n1. Random\n2. Ascending\n3. Descending" << std::endl;
		int plan;
		std::cin >> plan;
		if (plan < 1 || plan > 3)
			return 0;

		//  заполняем массив так, как нам надо
		arr = new int[n];
		for (int i = 0; i < n; ++i)
		{
			if (plan == 1)
				arr[i] = rand();
			else if (plan == 2)
				arr[i] = i;
			else arr[i] = n - i;
		}

		start = MPI_Wtime();  //  записываем время начала рассчета
		for (int i = 1; i < proc_num; ++i)  //  отправляем размер всем
			MPI_Send(&n, 1, MPI_INT, i, answerTag, MPI_COMM_WORLD);
	}
	else
	{
		//  принимаем размер n
		MPI_Recv(&n, 1, MPI_INT, 0, answerTag, MPI_COMM_WORLD, &st);
	}

	int* sendcounts = new int[proc_num];  //  кол-во элементов
	int* displs = new int[proc_num];  //  смещение
	int remainder = n;  //  остаток
	for (int i = 0; i < proc_num; ++i)
	{
		displs[i] = i > 0 ? displs[i - 1] + sendcounts[i - 1] - 1 : 0;  //  смещение = смещение старого значения + кол-во элементов у пред. элемента - 1
		sendcounts[i] = ceil(remainder / (double)(proc_num - i)) + (i != proc_num - 1 ? 1 : 0);  //  кол-во элементов = остаток / кол-во оставшихся процессов + (если процесс не последний, то добавляем границу следующего)
		remainder = remainder - (sendcounts[i] - 1);  //  остаток = остаток - (кол-во элементов - 1)
	}

	//  буфер для приёма
	int* buff = new int[sendcounts[proc_rank]];
	//  распределяем между процессами
	MPI_Scatterv(arr, sendcounts, displs, MPI_INT, buff, sendcounts[proc_rank], MPI_INT, 0, MPI_COMM_WORLD);

	//  получаем результат
	int res = checkArray(buff, sendcounts[proc_rank]);

	//  если главный процесс и упорядочено, то получаем значения других процессов и смотрим результат
	if (proc_rank == 0)
	{
		if (res != INT_MAX)
		{
			for (int i = 1; i < proc_num; ++i)
			{
				int temp;
				MPI_Recv(&temp, 1, MPI_INT, MPI_ANY_SOURCE, feedbackTag, MPI_COMM_WORLD, &st);
				if (res == 0)
					res = temp;
				else if (temp != res && temp != 0)  //  если значения не совпадают, значит массив не упорядочен
				{
					res = INT_MAX;
					break;
				}
			}
		}
		end = MPI_Wtime();
		std::cout << "Time: " << end - start << std::endl;
		std::cout << "Res: " << (res != INT_MAX ? (res == 1 ? "Ascending" : "Descending") : "FALSE") << std::endl;
	}
	else
	{
		//  отправляем результат главному процессу
		MPI_Send(&res, 1, MPI_INT, 0, feedbackTag, MPI_COMM_WORLD);
	}

	//  чистим память
	delete[] sendcounts;
	delete[] displs;
	delete[] arr;
	delete[] buff;

	MPI_Finalize();
	return 0;
}
=======
#include <iostream>
#include <math.h>
#include <mpi.h>
#include <string>
#include <algorithm>

using namespace std;

const int answerTag = 0;
const int feedbackTag = 1;

//  1 - по возрастанию, -1 - по убыванию, 0 - массив равен, INT_MAX - разные
int checkArray(int* arr, int size)
{
	int result = 0;
	for (int i = 1; i < size; ++i)
	{
		int temp = 0;
		if (arr[i - 1] < arr[i])
			temp = 1;
		else if (arr[i - 1] > arr[i])
			temp = -1;

		if (result == 0)
			result = temp;
		else if (result != temp && temp != 0)
		{
			result = INT_MAX;
			break;
		}
	}
	return result;
}

int main(int argc, char* argv[])
{
	int proc_rank, proc_num;
	MPI_Status st;
	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &proc_rank);
	MPI_Comm_size(MPI_COMM_WORLD, &proc_num);
	double start, end;
	int n;
	int* arr = NULL;
	if (proc_rank == 0)
	{
		std::cout << "Input N:";
		n = pow(10, 8);
		cout << n << endl;
		//std::cin >> n;
		std::cout << "Choose:\n1. Random\n2. Ascending\n3. Descending" << std::endl;
		int plan;
		std::cin >> plan;
		if (plan < 1 || plan > 3)
			return 0;

		//  заполняем массив так, как нам надо
		arr = new int[n];
		for (int i = 0; i < n; ++i)
		{
			if (plan == 1)
				arr[i] = rand();
			else if (plan == 2)
				arr[i] = i;
			else arr[i] = n - i;
		}

		start = MPI_Wtime();  //  записываем время начала рассчета
		for (int i = 1; i < proc_num; ++i)  //  отправляем размер всем
			MPI_Send(&n, 1, MPI_INT, i, answerTag, MPI_COMM_WORLD);
	}
	else
	{
		//  принимаем размер n
		MPI_Recv(&n, 1, MPI_INT, 0, answerTag, MPI_COMM_WORLD, &st);
	}

	int* sendcounts = new int[proc_num];  //  кол-во элементов
	int* displs = new int[proc_num];  //  смещение
	int remainder = n;  //  остаток
	for (int i = 0; i < proc_num; ++i)
	{
		displs[i] = i > 0 ? displs[i - 1] + sendcounts[i - 1] - 1 : 0;  //  смещение = смещение старого значения + кол-во элементов у пред. элемента - 1
		sendcounts[i] = ceil(remainder / (double)(proc_num - i)) + (i != proc_num - 1 ? 1 : 0);  //  кол-во элементов = остаток / кол-во оставшихся процессов + (если процесс не последний, то добавляем границу следующего)
		remainder = remainder - (sendcounts[i] - 1);  //  остаток = остаток - (кол-во элементов - 1)
	}

	//  буфер для приёма
	int* buff = new int[sendcounts[proc_rank]];
	//  распределяем между процессами
	MPI_Scatterv(arr, sendcounts, displs, MPI_INT, buff, sendcounts[proc_rank], MPI_INT, 0, MPI_COMM_WORLD);

	//  получаем результат
	int res = checkArray(buff, sendcounts[proc_rank]);

	//  если главный процесс и упорядочено, то получаем значения других процессов и смотрим результат
	if (proc_rank == 0)
	{
		if (res != INT_MAX)
		{
			for (int i = 1; i < proc_num; ++i)
			{
				int temp;
				MPI_Recv(&temp, 1, MPI_INT, MPI_ANY_SOURCE, feedbackTag, MPI_COMM_WORLD, &st);
				if (res == 0)
					res = temp;
				else if (temp != res && temp != 0)  //  если значения не совпадают, значит массив не упорядочен
				{
					res = INT_MAX;
					break;
				}
			}
		}
		end = MPI_Wtime();
		std::cout << "Time: " << end - start << std::endl;
		std::cout << "Res: " << (res != INT_MAX ? (res == 1 ? "Ascending" : "Descending") : "FALSE") << std::endl;
	}
	else
	{
		//  отправляем результат главному процессу
		MPI_Send(&res, 1, MPI_INT, 0, feedbackTag, MPI_COMM_WORLD);
	}

	//  чистим память
	delete[] sendcounts;
	delete[] displs;
	delete[] arr;
	delete[] buff;

	MPI_Finalize();
	return 0;
}
>>>>>>> ad22ee082dac6ece8d23d5999a86f8d8c86438df
